---
title: "当矩阵加密遇上已知明文：Hill Cipher的优雅破解"
date: 2025-11-15
draft: false
categories: ["CTF Writeup"]
tags: ["crypto", "线性代数", "已知明文攻击"]
---

有些密码学题目，暴力破解看似不可能，但换个角度看问题的结构，计算量就从天文数字降到了笔记本能跑的程度。这道 Hill Cipher 变体就是这样。

## 遇到了什么

拿到一段密文（30字节），加密方式是 Hill Substitution Cipher：一个 3x3 的未知矩阵 M 在 Z/256Z（模256整数环）上做矩阵乘法。明文按行填入 3x10 的矩阵 F，密文 R = M * F。

已知条件：明文的前几个字符和最后一个字符是固定的（flag格式）。

目标：恢复明文。

## 直觉上的困难

3x3矩阵有9个未知字节，每个取值 0-255，搜索空间 256^9 约等于 4.7 * 10^21。显然不能直接暴力。

## 怎么降维

解密公式是 F = M^{-1} * R。把矩阵乘法写开：

```
F[i][j] = M_inv[i][0] * R[0][j] + M_inv[i][1] * R[1][j] + M_inv[i][2] * R[2][j]
```

注意到 **F 的第 i 行只取决于 M_inv 的第 i 行**。这意味着9个未知数可以拆成三组独立的子问题，每组只有3个未知数。

每组的搜索量：遍历两个变量（256^2 = 65536），第三个变量从已知明文约束直接解出来。加上 printable 字符范围（32-126）的剪枝，实际候选更少。

256^9 降到 3 * 256^2 约等于 196608，差了十几个数量级。

## 具体做法

对 M_inv 的每一行 (a, b, c)：

1. 遍历 b, c 的所有可能（各 0-255）
2. 利用已知明文位置列方程，解出 a（模线性方程求解）
3. 用 (a, b, c) 解密该行对应的所有10个明文字节
4. 检查是否全部落在 printable ASCII 范围内（32-126）

```python
for c in range(256):
    for b in range(256):
        # 从已知明文列约束方程，解出 a
        # a * R[0][known_col] + b * R[1][known_col] + c * R[2][known_col] ≡ known_val (mod 256)
        # 这是一个模线性方程，256不是素数所以需要处理 gcd

        # 解出 a 后，检验所有10列解密结果是否 printable
        for j in range(10):
            v = (a * R[0][j] + b * R[1][j] + c * R[2][j]) % 256
            if v < 32 or v > 126:
                break  # 剪枝
```

每行的已知约束越多，搜索空间越小。有两个已知字节的行几乎能唯一确定；只有一个已知字节的行会多出几个候选（个位数），再根据 flag 格式排除即可。

## 模256的坑

Z/256Z 不是域（256 = 2^8，不是素数），所以模逆元不一定存在。具体来说，当 gcd(a, 256) > 1 时，线性方程 a*x ≡ b (mod 256) 要么无解，要么有多个解。代码里需要正确处理这个分支——先算 gcd，判断是否整除，再用扩展欧几里得求所有解。

做惯了 GF(p) 上的题容易忘这茬。

## 回头看

整道题的难度不在密码学本身（Hill Cipher 是教科书内容），而在于意识到可以按行拆解这一步。拿到题目的第一反应如果是"9个未知数暴力不了"然后去想格攻击或者 Meet-in-the-Middle，反而绕远了。

有时候最有效的优化就是把问题拆开。
