---
title: "DSA nonce 递增攻击：两次签名恢复私钥"
date: 2025-02-16
draft: false
description: "当 DSA 的 nonce k 每次签名后简单递增，两个连续签名就足以联立方程解出私钥"
categories: ["CTF Writeup"]
tags: ["crypto", "DSA", "nonce", "数论"]
---

## 题目

远程服务提供标准的 DSA 签名/验证功能，目标是伪造对指定消息的合法签名。服务给出公钥参数 (p, q, g)，允许你签任意消息，也可以提交签名进行验证。

翻一下签名函数的实现，关键就一行：

```python
k += 1
```

每次签名后 nonce 直接加一。

## 分析

DSA 签名的核心公式：

$$s = k^{-1}(H(m) + xr) \mod q$$

其中 $r = g^k \mod p \mod q$，$x$ 是私钥，$k$ 是 nonce。

正常情况下 $k$ 应该是密码学安全的随机数——如果两次签名用了同一个 $k$，就是经典的 Sony PS3 ECDSA 事故，直接解出 $x$。这题更温和一点：$k$ 不是重复，而是递增。但其实差不多，两个方程两个未知数（$x$ 和 $k$），完全可解。

## 推导

签两条不同的消息 $m_1$, $m_2$，得到签名 $(r_1, s_1)$ 和 $(r_2, s_2)$，对应的 nonce 分别是 $k$ 和 $k+1$。

从签名公式得到：

$$s_1 k = xr_1 + h_1 \pmod{q}$$
$$s_2(k+1) = xr_2 + h_2 \pmod{q}$$

其中 $h_i = \text{SHA256}(m_i)$。

从第一个方程解出 $k$：

$$k = s_1^{-1}(xr_1 + h_1) \pmod{q}$$

代入第二个方程：

$$s_2\left(s_1^{-1}(xr_1 + h_1) + 1\right) = xr_2 + h_2 \pmod{q}$$

展开整理，把 $x$ 归到一边：

$$x\left(\frac{r_2}{s_2} - \frac{r_1}{s_1}\right) = 1 - \frac{h_2}{s_2} + \frac{h_1}{s_1} \pmod{q}$$

这里的除法都是模 $q$ 下的乘法逆元。令：

$$A = r_2 s_2^{-1} - r_1 s_1^{-1} \mod q$$
$$B = 1 - h_2 s_2^{-1} + h_1 s_1^{-1} \mod q$$

则 $x = B \cdot A^{-1} \mod q$。

## 实施

1. 获取公钥参数 $(p, q, g)$
2. 签两条任意消息，拿到 $(r_1, s_1)$ 和 $(r_2, s_2)$
3. 按上面的公式算出私钥 $x$
4. 验证：用 $x$ 和第一个签名反推 $k$，检查 $g^k \mod p \mod q$ 是否等于 $r_1$
5. 拿着 $x$ 对目标消息签名，提交即可

用 gmpy2 的 `invert` 处理模逆元，整个求解过程十来行代码。

## 小结

DSA 的安全性严重依赖 nonce 的随机性。完全随机是底线，任何可预测的结构（重复、递增、线性关系）都会让攻击者建立方程组，进而恢复私钥。这题是最直接的演示：两次签名，两个方程，解两个未知数，没了。
